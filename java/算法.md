# 算法

## 复杂度

### 时间复杂度

1. 大O推导法

   * 用常数1取代运行时间中的所有加法常数
   * 在修改后的运行函数中，只保留最高阶项
   * 如果最高阶项存在且不是1，则去除与这个项相乘的常数

2. 常数阶

   * ```java
     int sum = 0; n = 10;     // 执行一次
     sum = (1 + n) * n / 2;   // 执行一次
     System.out.println(sum); // 执行一次
     ```

   * 上述代码运行次数f(n)=3，根据大O推导法，时间复杂度为O(1)

3. 线性阶

   * ```java
     for (int i = 0; i < n; i++) {
       // 时间复杂度为O(1)的程序
     }
     ```

   * 时间复杂度为O(n)

4. 对数阶

   * ```java
     int count = 1;
     while(count < n) {
       count = count * 2;
       // 时间复杂度为O(1)的程序
     }
     ```

   * 循环次数x，则$2^x = n$  -> $x = \log_2n$

   * 时间复杂度为O(logn)

5. 平方阶

6. 时间复杂度消耗的时间排序：

   * $$
     O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) <O(2^n) < O(n!) <O(n^n)
     $$

### 空间复杂度

## 排序算法

### 1. 插入排序

### 2. 冒泡排序

### 3. 快速排序

### 4. 合并排序

## 链表

## 栈、队列

### 1. 什么是栈、队列？

### 2. 栈的基本实现和基本操作接口

### 3. 栈实现队列和队列实现栈

## 树

### 1. 树的表示

### 2. 反转二叉树

### 3. 计算树的深度

### 4. 广度优先算法和深度优先算法

### 5. 树遍历的序？如何判断二叉树是不是二叉搜索树？

### 6. 平衡二叉树

## HashTable

### 1. HashTable的原理

### 2. Java的HashMap是如何实现的？

### 3. ConcurrentHashMap是怎么回事？什么时候用？

### 4. Java Object的hashCode是如何计算的？

