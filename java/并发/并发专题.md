# 并发

## Synchronized

### 1. Synchronized原理

1. Synchronized是由JVM实现的一种实现互斥同步的一种方式，被Synchronized修饰过的程序块，在编译前后被编译器生成了monitonrenter和monitorexit两个字节码指令。
2. 在虚拟机执行到monitorenter指定时，首先要尝试获取对象的锁，如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁，把锁的计数器+1；当执行monitorexit指令时，将锁计数器-1；当计数器为0时，锁就被释放了。
3. 如果获取对象锁失败了，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。
4. Java中Synchronized通过在对象头设置标记，达到了获取锁和释放锁的目的。

### 2. 锁是什么？如何确定对象的锁？

1. 锁的本质其实是monitorenter和monitorexit字节码指令的一个Reference类型的参数，即要锁定和解锁的对象。对象锁即为使用Synchronized修改的对象。
2. 如果Synchronized明确指定了锁对象，比如Synchronized(变量名)、Synchronized(this)等，说明加解锁对象为该对象。
3. 如果没有明确指定：
   * 若Synchronized修饰的方法为非静态方法，表示此方法对应的对象为锁对象
   * 若Synchronized修饰的方法为静态方法，则表示此方法对应的类对象为锁对象
   * 当一个对象被锁住时，对象里面所有用Synchronized修改的方法都将产生堵塞

### 3. 什么是可重入性？为什么说Synchronized是可重入锁？

1. 可重入性是锁的一个基本要起，是为了解决自己锁死自己的情况。
2. 在执行monitorenter指令时，如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁，就把锁计数器+1，其实本质上就通过这种方式实现了可重入性。

### 4. JVM对Java的原生锁做了哪些优化？

1. JDK1.6之前，Monitor的实现完全依赖底层操作系统的互斥锁来实现。将一个线程进行阻塞或唤起都需要从用户态切换到内核态来执行，成本高。
2. 一种优化是使用自旋锁。即在把进程进行阻塞操作之前，让线程自旋等待一段时间，可能在等待期间其他线程已经解锁，这是无需再让线程执行阻塞操作，避免了用户态到内核态的切换。
   * 缺点：
     * 单核处理器上，不存在实际的并行，当前线程不阻塞自己的话，旧owner就不能执行，锁永远不会释放，此时不管自旋多久都是浪费；进而，如果线程多处理器少，自旋也会造成不少无谓的浪费。
     * 自旋锁要占用CPU，如果是计算密集型任务，这一优化通常得不偿失，减少锁的使用是更好的选择。
     * 如果锁竞争的时间比较长，那么自旋锁通常不能获得锁，浪费了自旋占用的CPU时间。这通常发生在锁持有时间长，且竞争激烈的场景中，此时应主动禁用自旋锁。
3. 自适应自旋锁在自旋锁上再做优化，即自旋的时间不再固定了，而是由前一次在同一锁上的自旋时间及锁的拥有者的状态来决定：
   * 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。
   * 相反的，如果对于某个锁，自旋很少成功获得过，那么在以后要获取这个锁时将可能减少自旋时间甚至省略自旋过程，以避免浪费处理器资源。
   * 自适应自旋锁解决的是“锁竞争时间不确定”的问题。
   * 缺点：如果默认的自旋次数设置不合理（过高或过低），那么自适应的过程将很难收敛到合适的值。
4. 此外JDK还提供了三种不同的锁：
   * 偏向锁
   * 轻量级锁
   * 重量级锁
5. 偏向锁
   * 偏向锁的目标是：减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗。
   * 轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。
   * 偏向锁假定将来只有第一个申请锁的线程会使用锁，只需要在Mark Word中CAS记录owner，如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁。
   * 总结：无实际竞争，且将来只有第一个申请锁的线程会使用锁
6. 轻量级锁
   * 轻量级锁的目标是：减少无实际竞争情况下，使用重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。
   * 轻量级锁是相对于重量级锁而言的。使用轻量级锁时，不需要申请互斥量，仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争，膨胀为重量级锁。
   * 总结：有实际竞争，多个线程交替使用锁；允许短时间的锁竞争。
7. 重量级锁
   * 内置锁在Java中被抽象为监视器锁（monitor）
   * 这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。
   * 总结：有实际竞争，且锁竞争时间长
8. 附加知识：锁分配和膨胀过程
   * <img src="/Users/zefeng/Documents/workspace/study-md/java/4491294-e3bcefb2bacea224.webp" alt="4491294-e3bcefb2bacea224" style="zoom: 50%;" />
   * ![4491294-345a15342fad119a](/Users/zefeng/Documents/workspace/study-md/java/4491294-345a15342fad119a.webp)

### 5. 为什么说Synchronized是非公平锁？

* 非公平主要表现在获取锁的行为上，并非是按照申请锁的时间前后给等待线程分配锁的，每当锁被释放后，任何一个线程都有机会竞争到锁，这样做的目的是为了提高执行性能，缺点是可能会产生线程饥饿现象。

### 6. 什么是锁消除和锁粗话？

* 锁消除：
  * 指虚拟机即时编译器在运行时，对一些代码上要求同步，但被检测到不可能存在共享数据竞争到锁进行消除。即有时候代码完全不需要加锁，却执行了加锁操作，则将锁进行消除
  * 前提是java必须运行在server模式，同时必须开启逃逸分析：`-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks`
    * `-XX:+DoEscapeAnalysis`：表示开启逃逸分析
    * `-XX:+EliminateLocks`：表示锁消除
    * 逃逸分析：判断作用域。
* 锁粗化：
  * 指有些情况下希望把很多次锁的请求合并成一个请求，以降低段时间内大量锁请求、同步和释放带来的性能消耗。
  * 原则上，同步块的作用范围要尽量小。但是如果一系列的连续操作都对同一对象反复加锁和解锁，甚至加锁操作在循环体内，频繁地进行互斥同步操作也会导致不必要的性能消耗。
  * 锁粗化就是增大锁的作用域。

### 7. 为什么说Synchronized是一个悲观锁？乐观锁的实现原理又是什么？什么是CAS，它有什么特性？

1. Synchroinzed显然是一个悲观锁，因为它的并发策略是悲观的：不管是否存在竞争，任何的数据操作都必须要加锁、用户态与内核态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等操作。总是假设最坏的情况，每次读取数据的时候都默认其他线程会更改数据，因此需要进行加锁操作，当其他线程想要访问数据时，都需要阻塞挂起。
2. 随着硬件指令集的发展，可以使用基于冲突检测的乐观并发策略：
   * 先进行操作，如果没有其他线程征用数据，那操作就成功了；
   * 如果共享数据有征用，产生了冲突，那就要再进行其他的补偿措施。
   * 这种乐观的并发策略的许多实现不需要线程挂起，所以被称为非阻塞同步。
3. 乐观锁的核心算法是CAS（Compare and Swap，比较并交换），它涉及到三个操作数：内存值、预期值、新值。当切仅当预期值和内存值相等时才将内存值修改为新值。处理逻辑：
   * 首先检查某块内存的值是否跟之前我读取时的一样，如不一样则表示期间此内存值已经被别的线程更改过，舍弃本次操作
   * 否则说明期间没有其他线程对此内存值操作，可以把新值设置给此块内存。
4. CAS具有原子性，它的原子性由CPU硬件指令实现保证，即使用JNI调用Native方法调用由C++编写的硬件级别指令，JDK中提供了Unsafe类执行这些操作。
5. 理解CAS底层：（假如有3个线程并发要修改一个AtomicInteger的值）
   * 首先，每个线程都会先获取当前的值，接着走一个原子的CAS操作。原子的意思就是这个CAS操作一定是自己完整的执行完的，不会被别人打断。
   * 然后CAS操作里，会比较一下，现在的值是不是刚才获取到的那个值。如果是，说明没人改过这个值，然后设置成累加1之后的一个值。
   * 同理，如果有人在执行CAS的时候，发现之前获取的值跟当前值不一样，会导致CAS失败。失败之后，进入一个无限循环，再次获取值，接着执行CAS操作。

### 8. 乐观锁一定就是好的吗？

乐观锁避免了悲观锁独占对象的现象，同时也提高了并发性能。但也有缺点：

1. 乐观锁只能保证一个共享变量的原子操作，如果多个变量，乐观锁将变得力不从心，但互斥锁能轻易解决，不管对象数据多少及对象颗粒度大小。
2. 长时间自旋可能导致开销大。加入CAS长时间不成功而一直自旋，会给CPU带来很大的开销。
3. ABA问题。CAS的核心思想是通过对比内存值与预期值是否一样而判断内存值是否被改过，但这个判断逻辑不严谨，假如内存值原来是A，后来被一个线程改为B，最后又被改为了A，则CAS认为此内存值并没有发生改变，但实际上是有被其他线程改过的，这种情况对依赖过程值的情景的运算结果影响很大。解决的思路是引入版本号，每次变量跟新都把版本加一。

### 9. 什么是同步？Java有哪些同步器？

## 可重入锁ReentrantLock及其他显示锁

### 1. 跟Synchronized相比，可重入锁ReentrantLock其实现原理有什么不同？

* 锁的实现原理基本是为了达到一个目的：让所有的线程都能看到某种标记。
* Synchronized通过在对象头中设置标记实现了这一目的，是一种JVM原生的锁实现方式，而ReentrantLock以及所有基于Lock接口的实现类，都是通过用一个volitile修改的int型变量，并保证每个线程都能拥有对该int的可见性和原子修改，其本质是基于所谓的AQS框架。

### 2. 谈谈AQS框架

* AQS（AbstractQueuedSychronizer类）是一个用来构建锁和同步器的框架，各种Lock包中的锁（常用的有ReentrantLock、ReadWriteLock）以及Semaphore、CountDownLatch，甚至早期的FutureTask等，都是基于AQS来构建的。
* AQS在内部定义了一个`volatile int state` 变量，表示同步状态：当线程栈调用lock方法时，如果state=0，说明没有任何线程占有共享资源的锁，可以获取锁并将state=1；如果state=1，则说明有线程正在使用共享变量，其他线程必须加入同步队列进行等待。
* AQS通过Node内部类构成的一个双向链表结构的同步队列，来完成线程获取锁的排队工作，当有线程获取锁失败后，就被添加到队列末尾。
  * Node类是对要访问同步代码的线程的封装，包含了线程本身及其状态waitStatus，每个Node节点关联其prev结点和next结点，方便线程释放锁后快速唤醒下一个在等待的线程，是一个FIFO的的过程。
  * Node类有两个常量，SHARED和EXCLUSIVE，分别代表共享模式和独占模式。
    * 共享模式是一个锁允许多条线程同时操作（信号量Semaphore就是基于AQS的共享模式实现的）
    * 独占模式是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待（如ReentrantLock）
* AQS通过内部类ConditionObject构建等待队列（可有多个），当Condition调用wait()方法后，线程将会加入等待队列中，而当Condition调用signal()方法后，线程将从等待队列转移到同步队列中进行锁竞争。
* AQS和Condition各自维护了不同的队列，在使用Lock和Condition的时候，其实就是两个队列的相互移动。

### 3. 尽可能详尽地对比下Synchronized和ReentrantLock的异同。

ReentrantLock是Lock的实现类，是一个互斥的同步锁。

1. 从功能角度，ReentrantLock比Sychronized的同步操作更精细，甚至实现Synchronized没有的高级功能：
   * 等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，对处理执行时间非常长的同步块很有用
   * 带超时的获取锁尝试：在指定的时间范围内获取锁，如果时间到了仍然无法获取则返回。
   * 可以判断是否有线程在排队等待获取锁
   * 可以响应中断请求：与Synchronized不同，当获取到锁的线程被中断时，能够响应中断，中断异常将会被抛出，同时锁会被释放。
   * 可以实现公平锁。
2. 从锁释放角度，Synchronized在JVM层面上实现的，不但可以通过一些监控工具监控Synchronized的锁定，而且在代码执行出现异常时，JVM会自动释放锁定；但是使用Lock则不行，Lock是通过代码实现的，要保证锁一定会被释放，就必须将unLock()放到finally()中。
3. 从性能角度，Synchronized早期实现比较低消，对于ReentrantLock，大多数场景性能都相差较大。但在Java6中对其进行了非常多的改进，在竞争不激烈时，Synchronized的性能要优于ReentrantLock；在高竞争情况下，Synchronized的性能会下降，但是ReentrantLock的性能维持常态。

### 4. ReentrantLock是如何实现可重入性的？

* ReentrantLock内部自定义了同步器Sync（Sync既实现了AQS，又实现了AOS，而AOS提供了一种互斥锁持有的方式），其实就是加锁的时候通过CAS算法，将线程对象放到一个双向链表中，每次获取锁的时候，看下当前维护的那个线程ID和当前请求的线程ID是否一样，一样就可重入了。

### 5. 除了ReentrantLcok，还接触过JUC中的哪些并发工具？

JUC即java.util.concurrent及其子包，集中了Java并发的各种基础工具类：

* 提供了CountDownLatch、CyclicBarrier、Semaphore等，可是实现更加丰富多线程操作的同步结构。
* 提供了ConcurrentHashMap、有序的ConcurrentSkipListMap，或者通过类似快照机制实现线程安全的动态数组CopyOnWriteArrayList等，各种线程安全的容器。
*  提供了ArrayBlockingQueue、SynchorousQueue或针对特定场景的PriorityBlockQueue等，各种并发队列实现。
* 强大的Executor框架，可以创建各种不同类型的线程池，调度任务运行等。

### 6. 请谈谈ReadWriteLock和StampedLock

### 7. 如何让Java的线程彼此同步？你了解过哪些同步器？

### 8. CyclicBarrier和CountDownLatch看起来很相似，请对比一下。

### 9. AQS内部的CHL算法工作原理是什么？

### 10. 什么场景下需要锁可以重入？

### 11. 什么场景下用CountDownLatch？

### 12. 什么场景用Semaphore？

### 13. Phaser是怎么实现的？

### 14. 什么场景用到Exchanger？

### 15. CyclicBarrier

* 屏障（Barrier）：多个线程在一个屏障上互相等待，直到所有线程都到达了，再执行一个同步程序。





## Java线程池

### 1. Java中线程池是如何实现的？

### 2. 创建线程池的几个核心构造参数

### 3. 线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？

### 4. 既然提到可以通过配置不同参数创建不同的线程池，那么Java中默认实现好的线程池又有哪些？请比较异同。

### 5. 如何在Java线程池中提交线程？

## Java内存模型

### 1. 什么是Java的内存模型，Java中各个线程是怎么彼此看到对方的变量的？

### 2. 请谈谈volatile有什么特点，为什么它能保证变量对所有线程的可见性？

### 3. 既然volatile能够保证线程间的变量可见性，是不是就意味着基于volatile变量的运算就是并发安全的？

### 4. 请对比下volatile和Synchronized的异同。

### 5. 请谈谈ThreadLocal是怎么解决并发安全的？

### 6. 很多人都说要慎用ThreadLocal，谈谈你的理解，使用ThreadLocal需要注意些什么？

