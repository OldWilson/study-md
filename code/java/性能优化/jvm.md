# JVM

## 基础知识

### Java内存区域

#### 线程私有区域

* 程序计数器
  * 是当前线程所执行的字节码的行号指示器，每条线程都有一个独立的程序计数器
  * 正在执行java方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）
  * 如果还是Native方法，则为空
* 虚拟机栈
  * 是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
  * 每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程
  * 栈帧用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接、方法返回值和异常分派。栈帧随着方法调用而创建，随着方法结束而销毁
* 本地方法区
  * 为Native方法服务。
* 线程私有区域生命周期与线程相同，依赖用户线程的启动/结束

#### 线程共享区

* Java堆
  * 创建的对象和数组都保存在java堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。
* 方法区/永久代
  * 用于存储被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
* 线程共享区随虚拟机的启动/关闭而创建/销毁

#### 内存

### Java运行时内存

#### 新生代

* 用来存放新生的对象。一般占据堆1/3空间。由于频繁创建对象，所以新生代会频繁出发MinorGC进行垃圾回收。
* Eden区：Java新对象的出生地（如果占用内存很大，则直接分配到老年代）。当Eden区内存不够时就会触发MinorGC，对新生代进行一次垃圾回收。
* ServivorFrom：上一次GC的幸存者，作为这一次GC的被扫描者。
* ServivorTo：保留了一次MoniorGC过程中的幸存者。
* MinorGC过程（复制->清空->互换）
  * MinorGC采用复制算法
  * 首先，把Eden和ServivorFrom区域中存活的对象复制到ServivorTo区域（如果有对象的年龄达到了老年的标准，则复制到老年代区），同时把这些对象的年龄+1（如果ServivorTo不够位置了就放到老年区）。默认年龄达到15移到老年代。
  * 然后，清空Eden和ServivorFrom中的对象
  * 最后，ServivorTo和ServivorFrom互换，原ServivorTo成为下一次GC时的ServivorFrom区

#### 老年代

* 主要存放应用程序中生命周期长的内存对象。
* 在进行MajorGC前一般都先进行了一次MoniorGC，使得有新生代的对象晋入老年代，导致空间不够时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收。
* MajorGC过程
  * MajorGC采用标记清除算法
  * 首先，扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。
  * 耗时比较长。
  * MajorZGC会产生内存碎片，为了减少内存损耗，一般需要进行合并或标记出来方便下次直接分配。
* 当老年代也满了，就会抛出OOM（Out of Memory）异常。

#### 永久代和元空间

1. 永久代
   * 指内存的永久保存区域。主要存放Class和Meta（元数据）的信息。
   * Class在被加载的时候被放入永久区域，和存放实例的区域不同，GC不会在主程序运行期间对永久区域进行清理。因此会出现永久代随着加载的Class增多而胀满，最终抛出OOM异常。
2. 元空间
   * Java8中，永久代已被移除，被“元数据区”（元空间）所取代。
   * 与永久代最大区别：元空间并不在虚拟机中，而是使用本地内存。
   * 类的元数据放入native memory，字符串池和类的静态变量放入java堆中

### 垃圾回收与算法

1. 确定垃圾
   1. 引用计数法 -
      * 一个对象如果没有任何与之关联的引用，即引用计数为0，则这个对象是可回收对象
   2. 可达性分析
      * 如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。
      * 不可达对象不等价于可回收对象
      * 不可达对象变为可回收对象至少要经过两次标记过程
2. 标记清除算法（Mark-Sweep）
   * 最基础的垃圾回收算法，分为标记和清除两个阶段。
   * 标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间
   * 最大的问题是内存碎片化严重
3. 复制算法
   * 按内存容量将内存划分为等大小的两块。
   * 每次只是用其中一块，当这一块内存满后将尚存活的对象复制到另一块上，把已使用的内存清除
   * 内存效率高，不易产生碎片
   * 最大问题是可用内存被压缩到了原本的一半
4. 标记整理算法
   * 标记阶段与标记清除算法一致
   * 标记后将存活对象移向内存的一端。然后清除端边界外的对象
5. 分代收集算法
   * 根据对象存活的不同生命周期将内存划分为不同的域：老生代和新生代
   * 新生代与复制算法
   * 老年代与标记复制算法

### 四种引用类型

1. 强引用
   * 把一个对象赋给一个引用变量，这个引用变量就是一个强引用
   * 但一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的
   * 强引用是造成java内存泄漏的主要原因之一
2. 软引用
   * 软引用需要用SoftReference类来实现
   * 对于只有软引用的对象来说，当系统内存足够时不会被回收
   * 软引用通常用在对内存敏感的程序中
3. 弱引用
   * 弱引用需要用WeakReference类来实现。
   * 比软引用的生存期更短
   * 对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存
4. 虚引用
   * 虚引用需要PhantomReference类来实现
   * 不能单独使用，必须和引用队列联合使用。
   * 虚引用的主要作用是跟踪对象被垃圾回收的状态

### GC垃圾收集器

#### 1. Serial垃圾收集器

1. 单线程
2. 复制算法
3. java虚拟机运行在Client模式下默认的新生代垃圾收集器
4. 在进行垃圾收集的同时，必须暂停其他所有的工作线程，直至垃圾收集结束

#### 2. ParNew 垃圾收集器

1. Serial收集器的多线程版本
2. 复制算法
3. 在垃圾收集过程中同样也要暂停所有其他的工作线程
4. 默认开启和CPU数目相同的线程数。可以通过`-XX:ParallelGCThreads`参数来限制垃圾收集器的线程数
5. java虚拟机运行在Server模式下新生代的默认垃圾收集器

#### 3. Parallel Scavenge收集器

1. 新生代垃圾收集器，复制算法，多线程
2. 目标是程序达到一个可控制的吞吐量
3. 吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）
4. 高吞吐量可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务
5. 自适应调节策略

#### 4. Serial Old收集器

1. Serial垃圾收集器老年代版本，单线程，标记-整理算法
2. 主要是java虚拟机运行在Client模式下老年代的默认垃圾收集器

#### 5. Parallel Old收集器

1. Parallel Scavenge的老年代版本，多线程的标记-整理算法
2. 为了在老年代同样提供吞吐量优先的垃圾收集器

#### 6. CMS收集器

1. Concurrent mark sweep
2. 老年代垃圾收集器
3. 主要目标是获取最短垃圾回收停顿时间
4. 多线程的标记-清除算法
5. CMS工作机制：
   * 初始标记：只是标记一下GC Roots能直接关联的对象，速度很快，仍然需要暂停所有的工作线程
   * 并发标记：进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程
   * 重新标记：为了修正在并发标记期间，因用户程序继续进行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程
   * 并发消除：清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。

#### 7. G1 收集器

1. Garbage first垃圾收集器是目前垃圾收集器理论发展的最前沿结果
2. 基于标记-整理算法，不产生内存碎片
3. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收
4. G1收集器避免全区域垃圾收集，它把堆空间划分为大小固定的几个独立区域，有限回收垃圾最多的区域。

### JAVA IO/NIO

#### 1. 阻塞IO模型

1. 读写数据过程中会发生阻塞现象

#### 2. 非阻塞IO模型

1. 当用户线程发起一个read操作后，并不需要等待
2. 当返回结果是error时，可再次发送read操作，用户线程轮询

#### 3. 多路复用IO模型

1. 会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作
2. 轮询每个socket状态是在内核进行的
3. 一旦时间响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询

#### 4. 信号驱动IO模型

1. 在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。

#### 5. 异步IO模型

1. 只需要先发起一个请求，当接受内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了

#### 6. JAVA NIO

1. NIO主要有三大核心部分：Channel（通道）、Buffer（缓冲区）、Selector。
2. NIO基于Channel和Buffer进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。
3. Channel
   * 与IO中的Stream是差不多一个等级的，不过Stream是单向的（InputStream,OutputStream），channel是双向的
   * NIO中的Channel的主要实现有：
     * FileChannel
     * DatagramChannel
     * SocketChannel
     * ServerSocketChannel
4. Buffer
   * 缓冲区，实际上是一个容器，是一个连续数组
5. Selector
   * NIO的核心类
   * Selector能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理

### JVM类加载机制

![JVM类加载机制](C:\workspace\all\study-md\java\resource\JVM类加载机制.png)

#### 1. 加载

1. 在这个阶段，会在内存中生成一个代表这个类的java.lang.Class对象，作为方法去这个类的各种数据的入口

#### 2. 验证

1. 这这一阶段的目的主要为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全

#### 3. 准备

1. 这一阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间

#### 4. 解析

1. 解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程
2. 符号引用是class文件中的：
   * CONSTANT_Class_info
   * CONSTANT_Field_info
   * CONSTANT_Method_info
   * 等
3. 符号引用
   * 符号引用与虚拟机是实现的布局无关，引用的目标并不一定要已经加载到内存中
   * 各种虚拟机实现的内存布局可以各不相同，但是他们能接受的符号引用必须一致
4. 直接引用
   * 直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄
   * 如果有了直接引用，那引用的目标必定已经在内存中存在

#### 5. 初始化

1. 开始真正执行类中定义的Java程序代码

#### 6. 类构造器\<client>

1. 初始化阶段是执行类构造器\<client>方法的过程。
2. 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生产\<client>()方法
3. 以下几种情况不会执行类初始化：
   * 通过子类引用父类的静态字段，只会触发父类的初始化，不会触发子类的初始化
   * 定义对象数组，不会触发该类的初始化。
   * 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触 发定义常量所在的类。
   * 通过类名获取 Class 对象，不会触发类的初始化。
   * 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初 始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。
   * 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。

### 类加载器

* JVM通过双亲委派模型进行类的加载

#### 1. 启动类加载器-Bootstrap ClassLoader

1. 负责加载JAVA_HOME\lib目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可的类

#### 2. 扩展类加载器-Extension ClassLoader

1. 负责加载JAVA_HOME\ext目录中的，或通过java.ext.dirs系统变量指定路径中的类库

#### 3. 应用程序类加载器-Application ClassLoader

1. 负责加载用户路径(classpath)上的类库

#### 4. 双亲委派

1. 当一个类收到了类加载请求，首先不会 尝试自己去加载这个类，而是把这个请求委派给父类去完成，只有当父类加载器反馈给自己无法完成这个请求的时候，子类加载器才会尝试自己去加载。

