| 第一天       | 第二天                       | 第三天                | 第四天                |
| ------------ | ---------------------------- | --------------------- | --------------------- |
| 介绍Ansible  | 管理变量和事实               | 管理大项目            | 自动执行Linux管理任务 |
| 部署Ansible  | 实施任务控制                 | 利用角色简化Playbook  | QA                    |
| 实施Playbook | 在被管理节点上创建文件或目录 | 对Ansible进行故障排除 |                       |
|              |                              |                       |                       |

# 第一章 介绍Ansible

## 一 install-ansible

### 1 网络源

```bash
1. EPEL方式：
https://docs.fedoraproject.org/en-US/epel/#_quickstart
 # yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm
 
2.自定义编辑镜像站 
镜像站方式：
https://www.centos.org/
或
http://mirrors.163.com/centos/8/
或
https://developer.aliyun.com/mirror/centos?spm=a2c6h.13651102.0.0.3e221b11ZQrqR5

3. pip安装（版本较老不推荐）
pip 是一个现代的，通用的 Python 包管理工具，提供了对Python 包的查找、下载、安装、卸载的功能。
【foundation】
[root@bastion ~]# python3 --version
Python 3.6.8
[root@bastion ~]# rpm -qa | grep pip
python3-pip-9.0.3-13.el8.noarch
[root@bastion ~]# pip3 install ansible
```

### 2 培训环境安装（考点）

```bash
3、本地培训环境，开启classroom，bastion后在，ssh root@bastion后，通过yum安装。（也可以在workstation上安装，serverX不能安装）（考试时同样的安装方式）
【bastion】
[root@bastion ~]# yum install -y ansible
[root@bastion ~]# rpm -qc ansible
/etc/ansible/ansible.cfg   配置文件
/etc/ansible/hosts  清单文件

[root@bastion ~]# ansible --version 查看ansible的版本及当前正在应用的配置文件
```

# 第二章 部署Ansible

## 一 清单文件

### 1 系统默认的清单文件

```bash
[root@bastion ~]# vim /etc/ansible/hosts    安装默认生成清单文件

清单规则：
指定范围格式：通配符或正则表达式的方法
[START:END]
192.168.[0:15].[0:255] 表示 192.168.0.0-192.168.15.255
server[a:c].example.com  表示   a-c
server[01:15].example.com  表示   server01.example.com-server15

重点：
all： 所有主机
ungrouped ： 不属于任何一个组的所有主机

验证受管主机或组是否在清单内
ansible 主机成员/主机组 --list-hosts

重要：清单中含有名称相同的主机和主机组，ansible命令显示警告并以主机作为其目标，组被忽略。
```

### 2 自定义清单文件

#### 创建工作目录

```bash
[root@bastion ~]# su - student
[student@bastion ~]$ ansible --version
[student@bastion ~]$ mkdir /home/student/ansible
[student@bastion ~]$ cd  /home/student/ansible/
```

#### 编辑清自定义单文件

```bash
[student@bastion ansible]$ vim /home/student/ansible/inventory
servera           #未在组内的主机

[webservers]      #主机组
serverb           #主机组成员，也是一个主机
  
[dbservers]
172.25.250.[12:13]  #该ip表示两个主机172.25.250.12至172.25.250.13

[share:children]   #嵌套组名share是自定义的，但是:children是固定写法，表示webserver和dbserver在share的组中，是share的组成员
webserver		   #嵌套组里面只写组名
dbserver

#注意：不要在清单里书写无用的符号，及一些特殊符号。主机名称不要和主机组冲突，组名尽量不要用数字开头。

查看清单内有哪些主机
-i inventory  指定清单，清单可以有一份或多分，所以需要指定，inventory清单文件名称，可自定义
--list-hosts  列出清单中的主机
[student@bastion ansible]$ cd /home/student/ansible
[student@bastion ansible]$ vim /home/student/ansible/inventory
[student@bastion ansible]$ ansible servera -i inventory --list-hosts
[student@bastion ansible]$ ansible all -i inventory --list-hosts
[student@bastion ansible]$ ansible ungrouped -i inventory --list-hosts
```

### 3 多清单

```bash
[student@bastion ansible]$ ls      #当前只有一个清单inventory
inventory
[student@bastion ansible]$ cp inventory inventory2    #额外创建一份为inventory2
[student@bastion ansible]$ ls
inventory  inventory2
[student@bastion ansible]$ echo server100 > inventory2  #指定inventory2内主机 为server100
[student@bastion ansible]$ mkdir invdir         	  #创建存放清单文件夹
[student@bastion ansible]$ mv inv* invdir/  	      #将所有清单移动到invdir目录内
mv: cannot move 'invdir' to a subdirectory of itself, 'invdir/invdir'
[student@bastion ansible]$ tree invdir/				  #查看目录内文件结构
invdir/
├── inventory
└── inventory2
[student@bastion ansible]$ ansible-inventory --graph -i invdir
@all:
  |--@share:
  |  |--@prod:
  |  |  |--serverc
  |  |  |--serverd
  |  |--@test:
  |  |  |--serverb
  |--@ungrouped:
  |  |--server100
  |  |--servera
 	#发现可以看到两个清单的所有主机
```

### 4 自动调用清单

```bash
1. 将清单路径记录到ansible.cfg配置文件中，达到系统自动寻找调用的目的。
[student@bastion ansible]$ vim ansible.cfg
[defaults]
inventory      = /home/student/ansible/inventory   #清单路径写入配置文件
[student@bastion ansible]$ ansible-inventory --graph    #查看时不用再添加-i
@all:
  |--@share:
  |  |--@dbservers:
  |  |  |--172.25.250.12
  |  |  |--172.25.250.13
  |  |--@webservers:
  |  |  |--serverb
  |--@ungrouped:
  |  |--servera
```

## 二  配置文件

### 1 配置文件优先级（掌握）

```bash
1.默认路径
$ /etc/ansible/ansible.cfg
ansible --version

2.家目录
$ cp /etc/ansible/ansible.cfg /home/student/.ansible.cfg
ansible --version

3.当前工作目录
$ mkdir /home/student/ansible
$ cp /etc/ansible/ansible.cfg  /home/student/ansible
$ cd /home/student/ansible
ansible --version

4.环境变量
设置环境变量方法
# su - root
# vim  /etc/profile 最后一行
# export ANSIBLE_CONFIG=/opt/ansible.cfg   （此时/opt下需要有ansible.cfg配置文件）
# source /etc/profile   加载
# ansible --version
# su - student
$ ansible --version

取消环境变量方法
# rm -f  /opt/ansible.cfg
# unset ANSIBLE_CONFIG

只设置某个用户的环境变量：
su - student
$ cd ~
$ vim .bash_profile
$ export ANSIBLE_CONFIG=/opt/ansible.cfg
$ source ./bash_profile

优先级 ：变量＞当前目录＞用户家目录＞/etc
```

### 2 配置文件内容

```bash
[defaults]
# some basic default values...
inventory      =  /home/student/ansible/inventory   清单路径（很重要）
host_key_checking = False    免除记录公钥，ssh免yes  （很重要）
remote_user = root           远程用户是谁，（很重要）
#forks          = 5        并行数
#poll_interval  = 15       链接时间间隔
#sudo_user      = root      指定特权用户，暂时不用
#ask_sudo_pass = True       sudu密码暂时不用
#ask_pass      = True       远程密码暂时不用
#transport      = smart     #
#remote_port    = 22        远程端口
#module_lang    = C         语言 C语言
#module_set_locale = False   #暂时不用
#roles_path    = /etc/ansible/roles  角色存储的路径
#module_name = command       默认模块command
#jinja2_extensions = jinja2.ext.do,jinja2.ext.i18n       ansible支持的一些jinja2文件及语法
#vault_password_file = /path/to/vault_password_file      ansible vault的密码文件位置
#timeout = 10 ，如果网络不好，可以改为60左右，主要是看ssh是否稳定  
[privilege_escalation]       #特权账号设置
#become=True    		      是否开启特权
#become_method=sudo           特权功能选择sudo      
#become_user=root             特权用户为root
#become_ask_pass=False        远程是否使用密码，要true ，不要false
```

### 3 根据需要来定义配置文件

```bash
配置文件
1.用户可选超级用户或普通用户
[root@bastion]$ su - student
2.定义工作目录，存放所有配置文件
[student@bastion]$ mkdir ansible;cd ansible
3.制作配置文件
[student@bastion ansible]$ cp /etc/ansible/ansible.cfg .   #将配置文件复制到当前工作目录
[student@bastion ansible]$ ansible --version  #检测是否使用的当前工作目录的配置文件
4.编辑配置文件
[student@bastion ansible]$ vim ansible.cfg  
[defaults]
inventory = /home/student/ansible/inventory
host_key_checking = False     #设置远程免yes
remote_user = root			  #指定远程用户为root

[student@bastion ansible]$ ansible-inventory --graph   检测清单
@all:
  |--@share:
  |  |--@prod:
  |  |  |--serverc
  |  |  |--serverd
  |  |--@test:
  |  |  |--serverb
  |--@ungrouped:
  |  |--servera

```

## 三 执行一些临时命令，指定远程用户及密码

###  1 什么是Ad-hoc

```bash
Ad-hoc称为临时命令，简单说，就是在命令行界面，直接通过一条ansible命令，去指定主机执行指定指令，功能有限，主要用于临时部署，临时查询，一些简单的操作。

语法：
ansible <host-pattern> [options]

通用选项：
host-pattern：主机模式，就是清单中的主机、组、all、ungrouped等。
options:
-m module   	#【常用】模块，指定要执行使用的模块
-a         	    #【常用】模块参数，使用-m指定模块，该模块可能需要跟某些参数，此时参数就放在-a 后面的双引号内。不加-m 模块，直接使用 -a 指默认指定了 -m command 模块

例：
ansible servera -m 模块名称 -a 模块参数 
ansible servera  -m command -a 'hostname'
```

#### 将变量记录到清单中

```bash
[student@bastion ansible]$ vim inventory
...
[all:vars]   #针对所有主机设置变量，ansible_password是ansible定义的远程密码变量，固定写法。redhat是培训环境中root密码。
ansible_password=redhat
[student@bastion ansible]$ ansible servera -m command -a hostname 
servera | CHANGED | rc=0 >>
servera.lab.example.com
```

### 2 示例

```bash
[student@bastion ansible]$ ansible servera   -a hostname  
[student@bastion ansible]$ ansible servera  -m command -a 'useradd harry'
[student@bastion ansible]$ ansible servera  -m command -a 'echo 123456 | passwd --stdin harry'
[student@bastion ansible]$ ansible servera  -m command -a 'tail -1 /etc/shadow'
[student@bastion ansible]$ ansible servera  -m shell -a 'echo 123456 | passwd --stdin harry'
[student@bastion ansible]$ ansible servera  -m command -a 'tail -1 /etc/shadow'
[student@bastion ansible]$ ansible-doc user  #/EXAMPLE
[student@bastion ansible]$ ansible servera -m user -a 'name=bob comment=student'
[student@bastion ansible]$ ansible servera -m shell -a 'id bob'
```

### 3 练习：

```bash
使用ansible Ad-hoc命令部署yum仓库
[student@bastion ansible]$ cat adhoc.sh 
#!/bin/bash

ansible servera -m yum_repository -a 'name=EX294_BASE description="EX294 base software" baseurl=http://content/rhel8.4/x86_64/dvd/BaseOS file=haha gpgcheck=yes gpgkey=http://content/rhel8.4/x86_64/dvd/RPM-GPG-KEY-redhat-release enabled=yes' 

ansible servera -m yum_repository -a '\
name=EX294_STREAM \
description="EX294 stream software" \
baseurl=http://content/rhel8.4/x86_64/dvd/AppStream \
file=haha \
gpgcheck=yes \
gpgkey=http://content/rhel8.4/x86_64/dvd/RPM-GPG-KEY-redhat-release \
enabled=yes'
```

### 4  Ansible的远程用户

| ansibel.cfg                    | ansible cmd      | shell cmd                         |
| ------------------------------ | ---------------- | --------------------------------- |
| remote_user=root               | 临时执行 -u root | ssh root@servera                  |
| become=yes,become_ask_pass=yes | -b     -K        | 开启sudo功能，并且输入sudo密码    |
|                                | -k               | 输入ssh连接密码，做了免密就不用了 |

```bash
用户及连接选项：
-u USERNAME     # 指定远程主机以USERNAME运行命令
-k              # 认证密码，回车手动输入密码
--list-hosts    # 列出符合条件的主机列表，不执行任何命令
-i PATH         # --inventory(清单，即主机列表文件路径)=PATH,默认路径是 /etc/ansible/hosts
-K              # sudo:用户的密码（--sudo时使用）
-b，--become	    #启用特权功能
-k				#登录密码 
[student@bastion ansible]$ ansible servera -m ping -u student -b  -k -K
SSH password:  student   #远程密码

练习：
[student@bastion ansible]$ ansible servera -m command -a hostname -u student -b  -k -K
SSH password: 
BECOME password[defaults to SSH password]: 
servera | CHANGED | rc=0 >>
servera.lab.example.com
[student@bastion ansible]$ 
[student@bastion ansible]$ 
[student@bastion ansible]$ ansible servera -m command -a 'useradd tom' -u student -b  -k -K
SSH password: 
BECOME password[defaults to SSH password]: 
servera | CHANGED | rc=0 >>

[student@bastion ansible]$ ansible servera -m command -a 'id tom' -u student -b  -k -K
SSH password: 
BECOME password[defaults to SSH password]: 
servera | CHANGED | rc=0 >>
uid=1002(tom) gid=1002(tom) groups=1002(tom)
```

# 第三章 PLAYBOOK

## 一 vim 修改缩进

```bash
调整tab键缩进
vim ~/.vimrc
set tabstop=2   将vim的tab键缩进调至两格
set nu
set autoindent

整体缩进 视图模式
ctrl+v ， jjj(+G) ，I，(空格、空格)，esc
```

## 二 一个简单的PLAYBOOK及yaml语法

```bash
ansible官网playbook例子： https://docs.ansible.com/ansible/2.9/user_guide/playbooks_intro.html#playbooks-intro
yaml语法例子：
https://docs.ansible.com/ansible/2.9/reference_appendices/YAMLSyntax.html


1 #执行playbook之前先在受管节点添加yum源
[student@bastion ansible]$ vim /home/student/ansible/install.yml  
---        				#yaml语法，---开头
- hosts: servera        #主机模式  针对servera部署
  tasks:				#任务列表
  - name: install the latest version of Apache    #任务模块，注意和tasks有两格缩进，下面是模块
    yum:
      name: httpd
      state: latest
      
[student@bastion ansible]$ ansible-playbook playbook.yml --syntax-check

playbook: playbook.yml
[student@workstation playbook]$ ansible-playbook playbook.yml
 
```

```bash
继续上面的Playbook
---
- name: PLAY1
  hosts: servera
  tasks:
  - name: install  apache    
    yum:
      name: httpd
      state: latest
  - name: Copy using inline content
    copy:
      content: 'test web page'
      dest: /var/www/html/index.html
  - name: Start service httpd, if not started
    service:
      name: httpd
      state: started
  - name: permit apache
    firewalld:
      service: http
      permanent: yes
      state: enabled
      immediate: yes

      
[student@bastion ansible]$ ansible-playbook install.yml                      


测试curl http://servera/index.html
```

## 三 多个play

```bash
---
- name: PLAY1     				#PLAY1
  hosts: servera,serverb
  tasks:
  - name: install  apache
    yum:
      name: httpd
      state: latest
  - name: Copy using inline content
    copy:
      content: 'test web page'
      dest: /var/www/html/index.html
  - name: Start service httpd, if not started
    service:
      name: httpd
      state: started
  - name: permit apache
    firewalld:
      service: http
      permanent: yes
      state: enabled
      immediate: yes

- name: PLAY2				#PLAY2
  hosts: servera    
  tasks:
  - name: access servera
    uri:
      url: http://servera/index.html
    
 [student@workstation playbook]$ ansible-playbook playbook.yml --syntax-check

playbook: playbook.yml
[student@workstation playbook]$ ansible-playbook playbook.yml -v


以上实验，用ansible-doc 查询课程中的所有模块
yum        安装软件
service    管理服务
firewalld  管理防火墙
copy       拷贝，1有拷贝功能，2 可以将一段文本，复制到某个文件中，如文件不存在，则生成文件。
uri        网站连接测试
```

# 第四章 变量

## 4.1、变量

变量名=变量值，变量可以重复的应用到项目中，简化管理，应用对象可以是：

要创建的用户、要安装的软件包、要启动的服务、要删除的文件、互联网的文档等。

变量的命名：

名称必须以字母开头，并且只能含有字母、数字和下划线

有效变量：web_server 、 file1、remote_server_1

无效变量： web server 、 1st    file、 remote.file 、abc$123

定义变量：（playbook、读取变量文件）

### 4.1.1变量有效范围

全局范围：从命令行执行临时命令时指定的变量   最优先

play范围： 在playbook里面指定变量信息  其次

主机范围 ： 比如清单中主机或主机组指定变量（清单主机优先主机组） 优先级最低

### 4.1.2 清单中定义变量（主机范围，有限度最低）

```
【bastion】
[greg@bastion ansible]$ pwd
/home/greg/ansible
$ vim inventory 
172.25.250.9   ansible_password=redhat     给主机定义变量

[test]
172.25.250.10
[test:vars]
ansible_password=redhat   给主机组定义变量

[prod]
172.25.250.[11:12]

[balancers]
172.25.250.13

[all:vars]   给所有主机和主机组组定义变量
ansible_password=redhat


课上实验：
[all:vars]
ansible_user=root
ansible_password=redhat

[student@bastion ansible]$ ansible servera -m ping

```

### 4.1.3 在PLAYBOOK中定义和使用变量（play范围，有限度中）

```yaml
一、playbook用vars定义变量
#vim varible.yml
--- 
- name: 1
  hosts: 172.25.250.9
  vars：
  - username: tom
  tasks:
  - name: Add the user {{ username }}
    user:
      name: “{{ username }}”     使用变量时，变量开头要加“”双引号，非变量开头不用加双引号
      comment: haha
      
二、playbook用vars_files字段加载变量文件 
#vim varible.yml
--- 
- name: 1
  hosts: 172.25.250.9  
  vars_files:
  - vars/users.yml  （此文件自行创建）
  tasks:
  - name: Add the user {{ username }}
    user:
      name: “{{ username }}”     使用变量时，变量开头要加“”双引号，非变量开头不用加双引号
      comment:  haha

变量文件中的内容
[greg@bastion ansible]$mkdir vars
[greg@bastion ansible]$vim vars/users.yml
[greg@bastion ansible]$ cat vars/users.yml 
---
username: tom


额外：
也可以定义用户名or密码变量
可以在playbook里面加载变量
- name: 存储库
  hosts: all
  vars:
    ansible_password: redhat
```

### 4.1.4 通过命令行执行（全局范围，有限度高）

```bash
[greg@bastion ansible]$ ansible dev -m shell -a whoami -e ansible_user=root -e ansible_password=redhat
命令行使用变量优先级最高

在执行playbook时指定变量
ansible-playbook varible.yml -e username=harry
```

### 4.1.6  数组的表示方式：

```yaml
[greg@bastion ansible]$ vim vari.yml 
user1_A_name: zhang
user1_B_name: san
user1_C_name: /home/zhangsan
user2_A_name: li
user2_B_name: si
user2_C_name: /home/lisi
改写为
users:
  user1:
    A_name: zhang
    B_name: san
    C_name: /home/zhangsan
  user2:
    A_name: li
    B_name: si
    C_name: /home/lisi
    
应用方法1：
users.user1.A_name
users.user2.B_name

应用方法2：python字典
users['user1']['A_name']

例子：调用数组
# [student@bastion ansible]$ vim vari.yml
---
users:
  user1:
    A_name: zhang
    B_name: san
    C_name: /home/zhangsan
  user2:
    A_name: li
    B_name: si
    C_name: /home/lisi
    
# [student@bastion ansible]$ vim debug.yml
---
- name: useradd
  hosts: dev
  vars_files:
    - vari.yml
  tasks:
  - name: Add the user
    user:
      name: "{{ users.user1.A_name }}{{ users.user1.B_name }}"
      comment: name is zhangsan

[greg@bastion ansible]$ ansible-playbook debug.yml
[greg@bastion ansible]$ ansible dev -m shell -a 'tail -n 1 /etc/passwd'
```

### 4.1.7 实例2：通过debug模块调用变量

```
debug模块，可以使用到playbook中，它可以输出一些字符串，也可以输出变量，或者在执行playbook过程中获取的一些变量。
[greg@bastion ansible]$ vim debug.yml 
---
- name: debug message
  hosts: dev
  vars:
    ansible_password: redhat
    repo_name1: app
    repo_name2: base
  tasks:
  - name:
    debug:
      msg: one {{ repo_name1 }} two {{ repo_name2 }}
  - name:
    debug:
      var: ansible_password
      
[greg@bastion ansible]$ ansible-playbook debug.yml
```



```bash
[greg@bastion ansible]$ vim debug.yml 
---
- name: debug message
  hosts: dev
  vars_files：
  - var/var.yml
  tasks:
  - name:
    debug:
      msg: one {{ repo_name1 }} two {{ repo_name2 }}
  - name:
    debug:
      var: ansible_password
[greg@bastion ansible]$ mkdir var
[greg@bastion ansible]$ vim var/var.yml
---
ansible_password: redhat
repo_name1: app
repo_name2: base
[greg@bastion ansible]$ ansible-playbook debug.yml
```



### 4.1.7 register （了解）

将playbook的运行结果保存至一个临时变量中，方便再次调用。

```bash
1、如果要完成该实验，需要先做第二部在受管主机上保证配置了yum源
[greg@bastion ansible]$ vim register.yml
---
- name: install a packages
  hosts: dev
  tasks:
  - name: install the latest version of Apache
    yum:
      name: httpd
      state: latest
    register: install_result
  - name:  message
    debug:
      var：install_result

2、在另一个窗口：
ssh root@172.25.250.9
[root@workstation yum.repos.d]# ls
rhel.repo
[rhel]
name=EX294 base software
baseurl=http://content/rhel8.0/x86_64/dvd/BaseOS
gpgcheck=1
gpgkey=http://content/rhel8.0/x86_64/dvd/RPM-GPG-KEY-redhat-release
[rhel2]
name=EX294 app software
baseurl=http://content/rhel8.0/x86_64/dvd/AppStream
gpgcheck=1
gpgkey=http://content/rhel8.0/x86_64/dvd/RPM-GPG-KEY-redhat-release

3、验证
[greg@bastion ansible]$ ansible-playbook register.yml 
```

## 4.2 事实 facts

### 4.2.1 临时命令收集

```bash
[greg@bastion ansible]$ ansible localhost -m setup
[greg@bastion ansible]$ ansible localhost -m setup -a  filter=ansible_nodename
[greg@bastion ansible]$ ansible dev -m setup -a filter=*ipv4*
[greg@bastion ansible]$ ansible dev -m setup


playbook方式
[greg@bastion ansible]$ vim debug.ymlx
---
- name: debug message
  hosts: dev
  tasks:
  - debug:
      msg: "{{ ansible_facts['default_ipv4']['address'] }}"
      msg: "{{ ansible_facts.default_ipv4.address }} 
      msg: "{{ ansible_default_ipv4.address }}"
  或
  - debug：
      var: ansible_facts
[greg@bastion ansible]$ ansible-playbook debug.yml

```

### 4.2.2 关闭事实

```bash
[greg@bastion ansible]$ vim debug.yml
---
- name: debug message
  hosts: dev
  gather_facts： on/off  true/false
  tasks:
  - debug:
      msg: "{{ ansible_facts.default_ipv4.address }}"
      
[greg@bastion ansible]$ ansible-playbook debug.yml

如果playbook内容和事实收集没有关系，可以关闭可以大量减少playbook执行时间。
注意：考试时不要关闭
```

### 4.2.3 魔法变量

搜索facts

https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html

```bash
dosc.ansible.com中搜索magic
inventory_hostname  在清单中的主机名
group_names         当前主机归属于哪个组
groups 			    清单中的所有主机。以及他们所在组
hostvars			可以列出系统中所有魔法变量 ，加所有事实变量
ansible  dev -m debug -a var=inventory_hostname
ansible  dev -m debug -a var=groups
ansible  all -m debug -a var=group_names
ansible  all -m debug -a var=hostvars

或者通过playbook收集魔法变量信息
[greg@bastion ansible]$ vim hostvars.yml
---
- name: facts
  hosts: dev
  tasks:
  - debug:
      var: hostvars
      
 问题：如何列出所有主机在清单中的名字？

```

### 4.2.4 事实变量相关模拟题：

```
【考试环境bastion】
$ wget http://materials/hwreport.empty -P /root/hwreport.txt

[greg@bastion ansible]$ vim hw.yml
- name: report
  hosts: servera 
  tasks:
  - name: Copy using inline content
    copy:
      content: |
        HOST={{ inventory_hostname }}
        MEMORY={{ ansible_memtotal_mb }}
        BIOS={{ ansible_bios_version }}
        DISK_SIZE_VDA={{ ansible_devices.vda.size }}
        DISK_SIZE_VDB={{ ansible_devices.vdb.size }}
      dest: /root/hwreport.txt

```

## 4.3 ANSIBLE VAULT

```bash
一、给普通文件加密
[greg@bastion ansible]$ ls
ansible.cfg  debug.yml  inventory  
ansible-vault -h
ansible-vault encrypt debug.yml 
vim debug.yml 
ansible-vault view debug.yml 
ansible-vault edit  debug.yml 
vim debug.yml 
ansible-playbook debug.yml  --ask-vault-pass
ansible-vault decrypt  debug.yml 
vim debug.yml 

二、通过ansible-vault命令直接创建加密文件
ansible-vault create vault.yml
ansible-vault rekey  vault.yml

三、通过密码文件给敏感数据加密echo 123456 > 
[greg@bastion ansible]$ echo 123456 > passwd.txt
[greg@bastion ansible]$ ls
ansible.cfg  inventory     vault.yml  passwd.txt  
[greg@bastion ansible]$ ansible-playbook vault.yml --vault-password-file=/home/greg/ansible/passwd.txt（此文件中包含密码）

注意：当playbook中有加密文件时，执行playbook时也要使用加密文件的密码

四、将密码文件写入ansible.cfg 配置文件中
[greg@bastion ansible]$ vim ansible.cfg 
vault_password_file = /home/greg/ansible/passwd.yml
```

# 第五章 实施任务控制

## 5.1 循环

可以在loop循环列表里面定义一些循环体，使用item变量来应用loop中的信息

帮助：搜索loop可以搜到相应语法

https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html

### 5.1.1 未使用循环的方式

```
- name: service * 2
  hosts: dev
  tasks:
  - name: Start service nfs-server
    service:
      name: nfs-server
      state: started
  - name: Start service chronyd
    service:
      name: chronyd
      state: started
```

### 5.1.2 loop循环方式1：

```
- name: service * 2
  hosts: dev
  tasks:
  - name: Start service nfs-server
    service:
      name: "{{ item }}"
      state: started
    loop:
    - nfs-server
    - chronyd
```

### 5.1.3 loop循环方式2：列表形式

```
- name: service loop
  hosts: servera
  vars:
    servers:
    - nfs-server
    - chronyd
  tasks:
  - name: Start service
    service:
      name: "{{ item }}"
      state: stopped
    loop: "{{ servers }}"
```

### 5.1.4 loop循环方式3：

```
mkdir /home/student/ansible/vars/
   vim /home/student/ansible/vars/var.yml
   servers:
   - nfs-server
   - chronyd
 
  #playbook 
  - name: service loop
    hosts: servera
    vars_files:
    - /home/student/ansible/vars/var.yml
  tasks:
  - name: Start service
    service:
      name: "{{ item }}"
      state: stopped
    loop: "{{ servers }}"  
```

### 5.1.5 loop循环方式4:循环散列或字典列表

```yaml
---
- name: service loop
  hosts: dev
  tasks:
  - name: service loop
    user:
      name: "{{ item.name }}"  
      comment: "{{ item.comment }}"  
      state: present
    loop:
      - name: jane
        comment: tom
      - name: joe
        comment: harry
        
        

- name: service loop
  hosts: dev
  vars：
    users：
    - name: jane
      comment: tom
    - name: joe
      comment: harry
  tasks:
  - name: service loop
    user:
      name: "{{ item.name }}"
      comment: "{{ item.comment }}"
      state: present
    loop: "{{ users }}"
      
  -------
  vim vaifile.yml
  users：
    - name: jane
      comment: tom
    - name: joe
      comment: harry
      
vim user.yml      
- name: service loop
  hosts: dev
  vars_files:
  - vaifile.yml
  tasks:  
  - name: service loop
    user:
      name: "{{ item.name }}"
      state: present
      comment: "{{ item.comment }}"
    loop: "{{ users }}"
     
     
      
课上例子:
---
- name: service state
  hosts: dev
  tasks:
  - name: install the latest version of Apache
    yum:
      name: "{{ item }}"
      state: latest
    loop:
      - httpd
      - autofs
```

## 5.2 when 

### 5.2.1 when的第一个例子；

```
---
- name: service state
  hosts: all
  tasks:
  - name: install the latest version of Apache
    yum:
      name: "{{ item }}"
      state: present
    loop:
      - httpd
      - autofs
    when: inventory_hostname == '172.25.250.9'  (如果使用inventory_hostname这个魔法变量，要参考清单中的主机名称) 
    
and  与  多个条件同时为真才执行  
or   或  多个条件有一个为真就执行
```

### 5.2.2 第二个例子：

```yaml
---
- name: 安装软件包
  hosts: all
  tasks:
  - name: install the latest version of Apache
    yum:
      name: "{{ item }}"
      state: latest
    loop:
    - php
    - mariadb
    when: '"dev" in group_names or "test" in group_names or "prod" in group_names'

  - name: install the 'Development tools' package group
    yum:
      name: "@RPM Development Tools"
      state: present
    when: '"dev" in group_names'
    
  - name: upgrade all packages
    yum:
      name: '*'
      state: latest
    when: '"dev" in group_names'

```

### 5.2.3 常用when条件语句(重点，带default变量查询方法)

```bash
匹配一个主机，或多个主机
变量 == '字符串'
when: inventory_hostname == '172.25.250.9' or inventory_hostname == '172.25.250.11' or inventory_hostname == '172.25.250.12'
变量值存在  in  第二个变量
 when: '"dev" in group_names'
 when: '"dev" not in group_names'
 when: inventory_hostname != '172.25.250.9'
  
  
  
搜索引擎中搜索：filters --- Using filters to --- 搜索admin---default('admin', true) 

```

## 5.3 ignore_errors  跳过失败任务

```yaml
[greg@bastion ansible]$ vim ignore_errors.yml
---
- name: test error
  hosts: dev
  tasks:
  - name:  touch directory
    shell: mkdir  /a/b
#   ignore_errors: yes   第一次执行加#注释，第二次执行取消注释

  - name: Add the user
    user:
      name: johnd
```

## 5.4 实施处理程序

比如一种场景，每当修改apache服务配置文件后，需要重启服务。ansible中可通过处理程序帮助完成该工作。ansible可以在模块任务的后面添加‘notfiy（通知）’字段，来调用handlers处理程序 ，他不会像常规任务那样运行，当notfiy检测该模块对受管主机有改动，如果有则通知handlers处理程序工作，该程序是通过模块实现的，比如可指定service模块动作为重启。

handlers是缩进和tasks对齐

```bash
[greg@control ansible]$ vim handlers.yml
---
- name:
  hosts: node1
  tasks:
  - name: install the latest version of Apache
    yum:
      name: httpd
      state: latest

  - name: Copy using inline content
    copy:
      content: 'heihei'
      dest: /var/www/html/index.html
    notify:  restart httpd

  - name: Start service httpd, if not started
    service:
      name: firewalld
      state: started

  - firewalld:
      service: http
      permanent: yes
      state: enabled
      immediate: yes

  handlers:
  - name: restart httpd
    service:
      name: httpd
      state: restarted

```



## 5.5.1 block      block区域

```yaml
未使用block时：
---
- name: test error
  hosts: all
  tasks:
    - name:  touch file
      shell: mkdir  -p /a/b
      when: inventory_hostname == "node1"

    - name: Add the user
      user:
        name: johnd
      when: inventory_hostname == "node1"

使用block时
---
- name: test error
  hosts: all
  tasks:
  - block:
    - name:  touch file
      shell: mkdir  -p /a/b

    - name: Add the user
      user:
        name: johnd
    when: inventory_hostname == "172.25.250.9"

```

### 5.5.2 （block、rescue、always）定义区域中失败的任务

Ansible官方文档：搜索：rescue https://docs.ansible.com/ansible/latest/user_guide/playbooks_blocks.html

```yaml
---
- name: block
  hosts: all
  tasks:
  - name:
    block:
    - name: install http
      yum:
        name: http
        state: latest
    rescue:
    - name: install httpd
      yum:
        name: httpd
        state: latest
  
    always:  
    - name: Start service httpd, if not started
      service:
        name: httpd
        state: started
```



# 第六章 在被管理节点上创建文件或目录

## 6.1 文件模块介绍

file，copy，lineinfile

| 模块名      | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| blockinfile | 插入、更新 、删除，自定义标记先包围的多行文本块              |
| file        | 设置权限、所有者、SElinux上下文及常规文件、符号连接、硬链接等 |
| copy        | 远程copy，类似file，可以设置文件属性、SElinux上下文          |
| fetch       | 和copy类似，相反工作方式，从远端拷贝到控制节点               |
| lineinfile  | 改文件某一行时使用                                           |
| stat        | 检测文件状态，类似linux 中stat命令                           |
| synchronize | 围绕rsync一个打包程序。                                      |

### 6.1.1 sefcontext

```bash
- name: Allow apache to modify files
  sefcontext:
    target: '/var/www/html/index.html'
    setype: httpd_sys_content_t
    state: present
```

### 6.1.2 file,copy

```yaml
[file] 考试
- name: Change file ownership, group and permissions
    file:
      path: /var/www/html/index.html
      owner: apache
      group: apache
      mode: '0644'
      state: touch
      setype: default_t
      
(Choices: absent, directory, file, hard, link, touch)[Default: file]

[copy] 考试
- name: Copy file with owner and permissions
  copy:
    src: /srv/myfiles/foo.conf
    dest: /etc/foo.conf
    owner: foo
    group: foo
    mode: '0644'

      
  - name: Copy using inline content
    copy:
      content: "testweb"
      dest: /var/www/html/index.html
```

### 6.1.3 lineinfile，fetch

```bash
lineinfile 考试
 - name: Ensure SELinux is set to enforcing mode
    lineinfile:
      path: /etc/selinux/config
      regexp: '^SELINUX='
      line: SELINUX=permissive

fetch 将远端文件拷贝到本地
- name: Store file into /tmp/fetched/host.example.com/tmp/somefile
  fetch:
    src: /tmp/somefile
    dest: /tmp/fetched
    flat: yes

flat: 直接复制文件，重复会覆盖，不使用该选项则复制文件时创建一受管节点主机名的目录，将文件路径放置其中。

[blockinfile]
---
- name:
  hosts:  node1
  tasks:
  - name: Insert/Update HTML surrounded by custom markers after <body> line
    blockinfile:
      path: /opt/index.html
      marker: "<!-- {mark} ANSIBLE MANAGED BLOCK -->"
      insertafter: "<body>"
      block: |
        <h1>Welcome to {{ ansible_hostname }}</h1>
        <p>Last updated on {{ ansible_date_time.iso8601 }}</p>


synchronize

[stat]
---
- name:
  hosts:  node1
  tasks:
  - stat:
      path: /etc/passwd
    register: sym

  - debug:
      msg: "{{ sym }}"


template  考试
- name: Template a file to /etc/files.conf
  template:
    src: /mytemplates/foo.j2
    dest: /etc/file.conf


get_url  考试
- name: Download foo.conf
  get_url:
    url: http://example.com/path/file.conf
    dest: /etc/foo.conf

```

## 6.2 jinja2模板

### **6.2.1 第一个例子**

```shell
1、构建jinja2模板
[greg@control ansible]$ vim jinja.j2
{# host file #}
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6

{{ ansible_default_ipv4.address }} {{ ansible_fqdn }} {{  ansible_hostname }}


2、通过templete模块，同步模板文件至受管主机，同时收集事实变量值，将结果生成至相应文件中。
[greg@control ansible]$ vim temp.yml
---
- name: sync file
  hosts: node1
  tasks:
  - name: Template a file to /etc/files.conf
    template:
      src: jinja.j2
      dest: /opt/hosts

3、在受管节点上查看文件结果
[root@node1 opt]# cat /opt/hosts 
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6

172.25.250.9    node1.lab.example.com     node1
```

### 6.2.2 第二个例子：

```shell
1、在配置文件中定义ansible_managed功能，添加描述信息：“Ansible hahaha”
[greg@control ansible]$ vim ansible.cfg
[defaults]

ansible_managed = Ansible hahaha

2、在jinja2模板中调用该功能
{# host file #}
{{ ansible_managed }}
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6


{{ ansible_default_ipv4.address }} {{ ansible_fqdn }} {{  ansible_hostname }}

3、将该jinja2模板应用于playbook中后，执行playbook.3
[greg@control ansible]$ ansible-playbook temp.yml
---
- name: sync file
  hosts: node1
  tasks:
  - name: Template a file to /etc/files.conf
    template:
      src: jinja.j2
      dest: /opt/hosts
      
 4、受管节点查看结果
 [root@node1 opt]# cat /opt/hosts 
Ansible hahaha
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6


172.25.250.9 node1.lab.example.com node1
```

### 6.2.3 第三个例子：

```bash
1、通过debug模块查看到魔法变量groups.all中包含了清单主机列表
[greg@control ansible]$ ansible node1 -m debug -a var=groups.all
node1 | SUCCESS => {
    "groups.all": [
        "node1",
        "node2",
        "node5",
        "node3",
        "node4"
    ]
}

2、构建jinja2模板，并使用for循环结合魔法变量groups.all打印出列表中的值
[greg@bastion ansible]$ vim jinja2.j2
{# host file #}
{{ ansible_managed }}
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6


{% for host in groups.all %}
{{ host }}
{% endfor %}
	

3、执行playbook
[greg@control ansible]$ ansible-playbook temp.yml

4、受管主机上查看结果
[root@node1 opt]# cat /opt/hosts 
Ansible hahaha
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6

node1
node2
node5
node3
node4
```

### 6.2.4 第四个例子：

https://docs.ansible.com/ansible/latest/user_guide/playbooks_vars_facts.html

网站中查找关键字：facts  选择：Discovering variables: facts and magic variables   然后搜索hostvars[host]

```bash
生成/etc/hosts
$ cd /home/greg/ansible/
1、wget http://materials/hosts.j2
127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4
::1 localhost localhost.localdomain localhost6 localhost6.localdomain6
第一种写法：	
{% for i in groups['all'] %}
{{ hostvars[i]['ansible_facts']['default_ipv4']['address'] }} {{ hostvars[i]['ansible_facts']['fqdn'] }} {{ hostvars[i]['ansible_facts']['hostname'] }} 
{% endfor %}

另一种写法：
{% for i in node1 %}
{{ hostvars[i].ansible_facts.default_ipv4.address }} {{ hostvars[i].ansible_facts.fqdn }} {{ hostvars[i].ansible_facts.hostname }} 
{% endfor %}


2、 vim /home/greg/ansible/test.yml
---
- name: sync file
  hosts: all       #一定要用all，因为要收集5台主机的事实变量
  tasks:
  - name: Template a file to /etc/files.conf
    template:
      src: hosts.j2
      dest: /opt/HOSTFILE
    when: '"dev" in group_names'     #只要匹配dev组即可
    
3、
[greg@bastion ansible]$ ansible-playbook test.yml 


以json格式查看：
{{ hostvars[i]['ansible_facts'] |  to_nice_json }}
```







# 第七章 管理大项目

## 7.1 利用主机模式选择主机

```bash
[ad-hoc:]
ansible dev -m shell 
[playbook:]
- name:
  hosts: dev

清单的书写规则：

[START:END]
192.168.[0:15].[0:255] 表示 192.168.0.0-192.168.15.255
server[a:c].example.com  表示   a-c
server[01:15].example.com  表示   server01.example.com-server15
ipv6也可以通过[a:f]这种方式
重点：
all： 所有主机
ungrouped ： 不属于任何一个组的所有主机

验证计算机是否在清单内
ansible 主机成员 --list-hosts


二、playbook中hosts后面的写法，临时命令中host-pattern
hosts： all
hosts： ungrouped
hosts： '*'  和all相同
使用特殊字符时，必须添加单引号，否则不生效
hosts：'*.example.com'
hosts：'datacenter*'
列表形式
hosts：servera，serverb
hosts：webserver,serverc
hosts：'devops,server*'
冒号：取代逗号
hosts：lab,&datacenter 匹配lab组同时也属于datacenter组，顺序无所谓&符号时同时也属于的意思
hosts：datacenter,!test2.example.com  表示datacenter组，但不包括test2.。。这个主机
hosts：all,!datacenter1  所有组，但不包含datacenter1组
```

## 7.2 配置并行

```
[greg@bastion ansible]$ vim /etc/ansible/ansible.cfg 
#forks          = 5
```

## 7.3 滚动更新

```
 - name: sync file
   hosts: all
   serial: 2
   tasks：
```

## 7.4 包含和导入文件

如果playbook很长很复杂，可以拆分成较小的文件便于管理，以模块化管理，可以将多个不同功能的play，组合成一个主要的playbook，将文件中的任务列表插入play，这样可以将这种模块化的play应用到不同场景。

playbook

- httpd
- php

- mysql




playbook1(httpd)     playbook2 (php)   playbook3(mysql)---->new playbook

### 7.4.1 包含与导入

```bash
Ansible可以支持两种方法将文件放入playbook中：

包含：属于动态操作。playbook运行期间，使用到相关内容时处理所包含的内容
导入：属于静态操做。在运行开始之前，ansible在解析playbook时预处理导入内容
```

### 7.4.2 导入Playbook

```yaml
1.将两个playbook加入到主playbook
[greg@control ansible]$ cat one.yml 
---
- name:
  hosts: node1
  tasks:
  - name:
    yum:
      name: httpd
      state: latest
[greg@control ansible]$ cat two.yml 
---
- name:
  hosts: node1
  tasks:
  - name:
    service:
      name: httpd
      enabled: yes
      state: started
  
[greg@control ansible]$ cat three.yml 
---
- name: one
  import_playbook: one.yml
- name: two
  import_playbook: two.yml

2.在主playbook中和其他play交替使用
[greg@control ansible]$ cat four.yml 
---
- name: four
  hosts: node3
  tasks:
  - debug:
      msg: haha
  
- name: one  因为加载的是playbook所以需要顶头写无缩进。
  import_playbook: one.yml

```

### 7.4.3 导入和包含

```yaml
第一个tasks任务
[greg@bastion ansible]$ cat tasks/apache.yml 
---
- name:
  yum:
    name: httpd
    state: latest
- name:
  service:
    name: httpd
    enabled: yes
    state: started
第二个tasks任务
[greg@bastion ansible]$ cat tasks/firewall.yml 
---
- name:
  service:
    name: firewalld
    state: started
    enabled: yes
- name:
  firewalld:
    service: http
    permanent: yes
    state: enabled
    immediate: yes
    
    
包含和导入的方式：
包含
[greg@bastion ansible]$ cat playbook.yml 
---
- name:
  hosts: dev
  tasks:
  - include_tasks: tasks/apache.yml  
  - include_tasks: tasks/firewall.yml


导入+包含
[greg@bastion 了，ansible]$ cat playbook.yml 
---
- name:
  hosts: prod
  tasks:
  - include_tasks: tasks/apache.yml  
  - import_tasks: tasks/firewall.yml


```



# 第八章 利用角色简化PLAYBOOK

## 8.1 描述角色结构

角色的作用：提前写好角色任务或模板等，使用时直接应用即可。

角色优点：针对不同业务或功能，创建不同角色。

描述：

playbook：我们知道完成一个项目可以通过编写playbook

角色（roles）：编写角色过程中，我们可以将一个角色设置为一个功能，在一个大项目中可能会使用到多个角色来组成这个项目。在使用角色时要先定义保存角色的储存目录，在目录中创建多个角色，可以通过不同的角色组成，完成不同的项目，我们希望角色不要过于复杂并可以重复利用，以便完成不同项目的开发。

apache  

mysql   php

## 8.2 角色分类

自定义角色：根据生产需求自定义角色，应变性强，自行维护

系统角色：分为linux系统角色及rhel系统角色，rhel系统角色如果已订阅的化，可以支持更新。系统角色重复使用率高，健壮性强，厂商维护更新。功能范围单一

## 8.3 自定义角色

```bash
自定义角色流程
一、配置ansible.cfg文件中的roles-path
二、创建角色
三、完善角色功能
四、添加控制执行顺序


一、配置ansible.cfg文件中的roles-path
1、默认ansible会在roles子目录中查找。可以将自己的角色安装在~/ansible/roles子目录中。
默认路径：
$ ~/.ansible/roles:/usr/share/ansible/roles:/etc/ansible/roles
如果ansible无法找到该位置角色，会按照ansible.cfg中roles_path指定的目录中查找。
#在没有配置ansible.cfg中roles_path时，使用ansible-galaxy list查看可以看到~/.ansible/role路径提示

2、如果自定义工作目录情况下，我们可以自定义roles目录，并使用ansible.cfg中roles_path字段功能指定角色路径
[greg@bastion ansible]$ mkdir /home/greg/ansible/roles
[greg@bastion ansible]$ vim ansible.cfg
roles_path    = /home/greg/ansible/roles
[greg@bastion ansible]$ ansible-galaxy role --help
[greg@bastion ansible]$ ansible-galaxy list
# /home/greg/ansible/roles

二、创建角色

[greg@bastion ansible]$ ansible-galaxy init roles/apache
- roles/apache was created successfully
[greg@bastion ansible]$ ansible-galaxy role --help
[greg@bastion ansible]$ ansible-galaxy list
# /home/greg/ansible/roles
- apache, (unknown version)
[greg@bastion ansible]$ tree roles/apache
apache
    ├── defaults　　　　　　　角色默认变量
    │   └── main.yml
    ├── files				引用的静态文件，可以是一些文件，网页模板等。
    ├── handlers　　　　　　　　处理程序，通常通过模块完成的
    │   └── main.yml
    ├── meta				作者，许可、兼容性
    │   └── main.yml
    ├── README.md　　　　　　　
    ├── tasks　　　　　　　　　　任务，任务的组成就是模块应用，也是角色的主要功能
    │   └── main.yml       
    ├── templates　　　　　　　　模板文件，通常使用ｊｉｎｊａ２模板　
    ├── tests					测试
    │   ├── inventory			
    │   └── test.yml
    └── vars				　　角色变量
        └── main.yml
	（用不到的目录可以删除，如default、vars、tests）

三、定义角色内容
#可以使用ROLENAME/tasks/main.yml任务文件的方式，它是有角色运行的主要任务列表。此文件中不用写play抬头信息，只写模块信息，直接顶头即可。
[greg@bastion ansible]$ vim roles/apache/tasks/main.yml
---
# tasks file for roles/apache
- name: install the latest version of Apache
  yum:
    name: httpd
    state: latest
- name: Start service httpd, if not started
  service:
    name: httpd
    state: started
    enabled: yes
- name: Template a file to /etc/files.conf
  template:
    src:  index.html.j2
    dest: /var/www/html/index.html
    owner: root
    group: root
    mode: '0644'
  notify:    #当该步骤有改变就调用notify否则不调用
  - restart httpd1

- name: permit httpd service
  firewalld:
    service: http
    permanent: yes
    state: enabled
    immediate: yes

＃创建模板文件
[greg@bastion ansible]$ vim roles/apache/templates/index.html.j2
Welcome to {{ ansible_nodename }} on {{ ansible_hostname }} and {{ ansible_default_ipv4.address }}

＃创建处理程序	
[greg@bastion ansible]$ vim roles/apache/handlers/main.yml
---
# handlers file for roles/apache
- name: restart httpd1
  service:
    name: httpd
    state: restarted


四、在playbook中使用角色
[greg@bastion ansible]$ vim playbook.yml
---
- name:
  hosts: webservers
  roles:
  - apache

```

## 8.4 控制执行顺序

```
#控制执行顺序
$例子：
一般我们会在playbook中tasks下面直接应用relos，如果你想在角色之前执行任务，需要加pre_tasks,后面的话加post_tasks。

- name: xxx
  hosts: xxx
  pre_tasks
  roles
  post_tasks
  
结合上面的例子，添加控制执行顺序
[greg@bastion ansible]$ vim playbook.yml
---
- name: install apache
  hosts: dev
  
  pre_tasks:
  - debug:
      msg: 'web server'
      
  roles:
  - apache
  
  post_tasks:
  - name: Copy file with owner and permissions
    copy:
      src: roles/apache/files/index2.html
      dest: /var/www/html/index2.html
      
＃在files目录中创建文件
vim roles/apache/files/index2.html
web  server

  
```

## 8.5 使用角色变量

```bash
---
- name: install apache
  hosts: all
  roles:
    - user.example
    - nfs
在角色里面使用变量
---
- name: install apache
  hosts: all
  roles:
  - user.example
  - nfs
    var1: name1     当前下面两个变量是给nfs这个角色使用的
	var2: name2  
	变量优先级playbook---》角色目录中vars----角色目录中defaults

```

## 8.6 系统角色

### 8.6.1 简化配置管理

linux6时间服务ntpd，linux7，chronyd，管理员必须配置两个服务，如果用系统角色system-roles.timesync角色就可以配置6、7的时间同步。

### 8.6.2 安装系统角色

```bash
1、安装
系统帮助我们定义了一些角色，有不同的功能，需要通过安装软件包。
[greg@bastion /]$ cd /
[greg@bastion /]$ sudo yum search roles
[greg@bastion /]$ sudo yum install -y rhel-system-roles.noarch
[greg@bastion /]$ ansible-galaxy list    #再根下查看角色路径，为默认角色路径
# /usr/share/ansible/roles     #系统角色路径
- linux-system-roles.kdump, (unknown version)
....
- rhel-system-roles.timesync, (unknown version)
# /etc/ansible/roles
 [WARNING]: - the configured path /home/greg/.ansible/roles does not exist.
 
2、定义角色路径
$ cd /home/greg/ansible/   #在ansible工作目录中查看时属于greg用户定制的角色路径
$ vim ansible.cfg
roles_path    = /home/greg/ansible/roles:/usr/share/ansible/roles
$  ansible-galaxy list
[greg@control ansible]$ ansible-galaxy list
# /home/greg/ansible/roles
- apache, (unknown version)
# /usr/share/ansible/roles
- linux-system-roles.kdump, (unknown version)
- linux-system-roles.network, (unknown version)
- linux-system-roles.postfix, (unknown version)
- linux-system-roles.selinux, (unknown version)
- linux-system-roles.timesync, (unknown version)
- rhel-system-roles.kdump, (unknown version)
- rhel-system-roles.network, (unknown version)
- rhel-system-roles.postfix, (unknown version)
- rhel-system-roles.selinux, (unknown version)
- rhel-system-roles.timesync, (unknown version)

3、如果想使用自己的角色以及系统角色
rpm -ql rhel-system-roles.noarch | grep timesync
cp /usr/share/doc/rhel-system-roles/timesync/example-timesync-playbook.yml /home/greg/ansible/timesync.yml

编辑系统角色
vim timesync.yml 	 	
---
- hosts: all
  vars:
    timesync_ntp_servers:
      - hostname: 172.25.254.254
        iburst: yes
  roles:
    - rhel-system-roles.timesync

使用系统角色
ansible-playbook timesync.yml

查询验证
ansible all -a 'chronyc sources -v'
```

### 8.6.3 使用时间同步系统角色

```bash
使用系统角色前，规划好角色路径，内容查看上面系统角色部分。
$ rpm -ql rhel-system-roles.noarch
$ cp /usr/share/doc/rhel-system-roles/timesync/example-timesync-playbook.yml /home/greg/ansible/timesync.yml

[greg@bastion ansible]$ vim timesync.yml
---
- hosts: all 
  vars:
    timesync_ntp_servers:
      - hostname: 172.25.254.254
        iburst: yes 
  roles:
    - rhel-system-roles.timesync
    
[greg@bastion ansible]$ ansible-playbook timesync.yml
测试结果
$ ansible all -a 'chronyc sources -v'


删除角色
[greg@bastion ansible]$ ansible-galaxy remove balancer （不用指定角色路径，直接写角色名称）
- successfully removed balancer
```

## 8.7 开发角色推荐做法

1、用版本库控制自己角色，也可以通过github

2、存储库不建议存放敏感信息

3、使用ansible-galaxy init 创建角色的目录中以及存放角色目录中不要放没用的目录信息

4、写好readme，和mate，功能、版本、通途、依赖

5、建议针对不同功能创建多个不同角色，而不是一个角色承载多个任务

6、经常重构角色，让你的角色更加完善。

# 环境设置

```bash
[kiosk@foundation0 ~]$ cat > ${COURSE}.sh <<EOF
> #!/bin/bash
> nmcli con down 'Wired connection 1'
> rhe-clerarocures 0
> rht-setcourse ${COURSE}
> rht-vmctl start classroom
> rht-vmctl start all
> EOF
```

通过文件安装角色：

https://docs.ansible.com/ansible/latest/galaxy/user_guide.html#installing-multiple-roles-from-a-file



# 第九章 排错

执行playbook的时候，根据报错排错，

1、给你一个playbook你需要修复他们

2、查看主机清单，配置文件中出现的错误



##### ANSIBLE 日志文件

排错当中最常用的就是log日志。

默认ansible配置不将输入记录到任何日志文件，它提供了一个内容之日志基础架构，可以通过ansible.cfg中的defaults里面log_path参数进行配置。或者通过$ANSIBLE_LOG_PATH变量来配置。如果配置了以上介绍的两种其一方式，ansible和ansible-playbook命令的输出会存储到日志文件中。

如果使用日志建议通过logrotate来管理。

```bash
当ansible执行playbook或其他操作发生报错，会记录到日志。
vim /etc/ansible/ansible.cfg 
#log_path = /var/log/ansible.log      文件将产生在/var/log/ansibel.log 普通用户不能写

如果普通用户使用操作方法：
[greg@bastion ansible]$ vim /home/greg/ansible/ansible.cfg   #普通用户日志存放位置尽量存在家目录中，防止没有写入权限。
log_path = /home/greg/ansible/ansible.log
然后执行一个playbook之后就会产生日志信息，否则不会生成ansible.log

建议：如果日志文件较大，可以使用logrotate做切割
```

##### debug

```bash
ansible dev -m setup -a filter=*lvm*    已经收集事实
ansible dev -m debug -a var=ansible_lvm  没有收集到事实，所以未查出变量值
 
使用playbook查看debug模块的变量值，在执行playbook之前会收集事实，然后通过debug模块显示出变量信息
---
- name:
  hosts: all
  tasks:
  - debug:
      msg: System {{ inventory_hostname }} disk size {{ ansible_devices.vdb.size }}
    when: ansible_devices.vdb is defined
通过debug模块，收集受管节点信息，方便管理员对其进行后续处理。
 
 
 关闭事实收集
如果要关闭收集，可以编辑配置文件
gathering = explicit
或者在playbook里
gather_facts: yes/no  true/false
```

##### -vvvv

```
ansible-playbook debug.yml -v 显示详细信息-vvvv显示更详细的信息
```

##### --syntax-check

```
[greg@bastion ansible]$ ansible-playbook playbook.yml --syntax-check
playbook: playbook.yml
```

##### --step 手动控制执行的步骤

```
[greg@control ansible]$ ansible-playbook playbook.yml --step

PLAY [PLAY1] ********************************************************************************************
Perform task: TASK: Gathering Facts (N)o/(y)es/(c)ontinue: n

手动输入n  y c来控制playbook中执行的步骤
n 不执行该步骤
y 执行该步骤
c 继续自动执行到结束

通过该方法，我们可以让有问题的步骤执行，而无关紧要的步骤可以跳过不执行。达到排错的目的。
```

##### --start-at-task 从指定步骤执行任务

```
[greg@control ansible]$ ansible-playbook playbook.yml --start-at-task='Start service httpd'

选项“
--start-at-task    #指定具体执行步骤，等号后面指定模块的描述，如果描述内容中有空格，建议用单或双引号引起来，表示为一个参数。
```

##### -C --check 烟雾测试

```bash
烟雾测试：在管理节点执行剧本，显示剧本的真实执行结果，但是不在受管节点上部署。
[greg@control ansible]$ ansible-playbook playbook.yml --help | grep \\-C
[greg@control ansible]$ vim playbook.yml
---
- name: PLAY1
  hosts: node2
  tasks:
  - name: install  apache
    yum:
      name: httpd
      state: latest
  - name: Copy using inline content
    copy:
      content: 'test web page'
      dest: /var/www/html/index.html
  - name: Start service httpd
    service:
      name: httpd
      state: started
  - name: Start service firewalld
    service:
      name: firewalld
      state: started
  - name: permit apache
    firewalld:
      service: http
      permanent: yes
      state: enabled
      immediate: yes
[greg@control ansible]$ ansible-playbook playbook.yml -C
```

##### 通过发送脚本解决问题

```bash
[greg@control ansible]$ cat test.sh   #自定义脚本名及内容
#!/bin/bash
date
[greg@control ansible]$ vim debug.yml #剧本名自定义
---
- name:
  hosts: node1
  tasks:
  - name: Run a script
    script: /home/greg/ansible/test.sh    #使用script模块，加脚本文件路径
    register: haha   #register收集上面模块执行结果至 haha（自定义名称）的这个变量中
  - debug:
      var: haha   #通过debug模块将haha变量的值打印出来。
[greg@control ansible]$ ansible-playbook debug.yml     

`如果不想写register，可以执行剧本时添加-v 类似：ansible-playbook debug.yml -v`
```

##### 排错

```
排错点：
一、配置文件
未解除注释
未指定规定路径或用户
角色路径地址写错
没指定远程超级用户
清单路径错误
没关闭指纹验证

二、清单
配置文件中清单路径
清单文件名称
清单内容

三、playbook
name：  冒号后面要空格，内容随意
hosts： all 指定的主机不在清单中，报错无partten
syntax-errors：注意格式缩进，2格缩进
变量设置错误，或调用时错误（变量名写错，变量开头要加双引号）
when条件： （逻辑判断思路错误，或书写错误）



四、角色排错
1、角色路径 如：roles_path=
2、创建角色    ansible-galaxy init apache  所在路径：/home/greg/ansible/roles
3、编辑角色    关注：roles/apache/tasks/main.yml 关注任务文件中的配做错误
4、使用角色  
---
- name:  install apache 
  hosts: webservers
  roles:
  - apache

提示：
参考答案经过了验证
按自己的方法做，一定要验证结果是否和考试要求一致
```



##### 教材中的案例与设置课程

```
[kiosk@foundation0 ~]$ rht-clearcourse 0 清除所有课程
[kiosk@foundation0 ~]$ rht-setcourse rh294 设置成ansible课程环境就可以运行课程内的脚本了（如果要设置rh134，把rh294环境rh134即可。）
验证方法：
设置后在所有应用里面Education里面可以看到abcd四个学员机，就证明切换成功了
```

# 第十章 自动执行Linux管理任务

### yum模块

```bash
bastion ansible]$ ansible-doc -l | grep yum

可以使用yum_repository模块配置yum源,并且将多仓库路径保存至同一文件中。
[control]
---
- name:
  hosts: node1
  tasks:
  - name: Add multiple repositories into the same file (1/2)
    yum_repository:
      name: EX294_BASE
      description: EX294 base software
      file: rhel
      baseurl: http://content/rhel8.4/x86_64/dvd/BaseOS
      gpgcheck: yes
      gpgkey: http://content/rhel8.4/x86_64/dvd/RPM-GPG-KEY-redhat-release
      enabled: yes

  - name: Add multiple repositories into the same file (1/2)
    yum_repository:
      name: EX294_STREAM
      description: EX294 stream software
      file: rhel
      baseurl: http://content/rhel8.4/x86_64/dvd/AppStream
      gpgcheck: yes
      gpgkey: http://content/rhel8.4/x86_64/dvd/RPM-GPG-KEY-redhat-release
      enabled: yes
测试方法：
[greg@control ansible]$ ansible all -a 'yum repolist all'

[node1]
[root@node1 yum.repos.d]# cat rhel.repo

[greg@bastion ~]$ ansible-doc rpm_key   
- rpm_key:
    state: present
    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt
```

##### 优化多软件包

```bash
---
- name:
  hosts: all
  tasks:
  - name: install the latest version of Apache
    yum:
      name: httpd
      state: latest
  - name: install the latest version of Apache
    yum:
      name: php
      state: latest

- name: install the latest version of Apache
    yum:
      name: "{{ item }}"
      state: latest
    loop:　
      - httpd
      - php

- name: install the latest version of Apache
    yum:
      name:
      - httpd
      - php
      state: latest
 
- name: ensure a list of packages installed
  yum:
    name: "{{ packages }}"
  vars:
    packages:
    - httpd
    - httpd-tools

      
等同于：yum install -y httpd php
或
loop的这种方式，系统会执行两次独立事务，对每个事务应用一个软件包

yum模块：

state： absent删除, installed,  present确保安装  latest升级到最新版本
latest 等同  yum update

yum remove  yum install 

 name： '*'  代表所有软件包
 name: "@RPM Development tools"   ansible命令里面安装包组要加@
```

### 管理引导过程和调度进程

##### at

```yaml
---
- name:
  hosts: dev
  tasks:
  - name: Schedule a command to execute in 20 minutes as root
    at:
      command: ls -d / >/dev/null
      count: 20
      units: minutes
      
默认是创建一个任务，给root，删除的	话使用选项state：absent
```

##### cron 

```bash
[greg@bastion ansible]$ cat cron.yml 
---
- name:
  hosts: all
  tasks:
  - name: Ensure a job that runs at 2 and 5 exists. 
    cron:
      name: "check dirs"
      minute: "*/2"
      hour: "5,2"
      day: 1-10
      user: harry
      job: "ls -alh > /dev/null"
     

[greg@bastion ansible]$ ansible dev -m shell -a 'crontab -u harry -l'

```

##### service

```bash
---
- name:
  hosts: dev
  tasks:
  - name: install the latest version of Apache
    yum:
      name: httpd
      state: latest
          
  - name: Start service httpd, if not started
    service:
      name: httpd
      state: started
      enabled: yes
~                  
```

##### systemd	

```yaml
[greg@bastion ansible]$ cat systemd.yml 
---
- name:
  hosts: dev
  tasks:
  - name: install the latest version of Apache
    yum:
      name: httpd
      state: latest

  - name: Make sure a service is running
    systemd:
      state: started
      name: httpd
      enabled: yes
      
测试命令：
ansible dev -m shell -a 'systemctl status httpd'
ansible dev -m shell -a 'systemctl is-enabled httpd'
```

reboot

```
- name: Unconditionally reboot the machine with all defaults
  reboot:

```

##### command

##### shell

### 管理用户和身份验证

##### group

```yaml
[greg@bastion ansible]$ cat group.yml 
---
- name:
  hosts: dev
  tasks:
  - name: create admin group
    group:
      name: grouptest
      gid： 10000

等同于：groupadd  grouptest
等同于：groupadd -g 10000 grouptest
```

##### user

```bash
需求:在node1上创建用户tom 附加组为group1，并设置密码为512方式哈希，uid =2000
user这个模块类似这些功能： useradd userdel suermod

[greg@bastion ansible]$ cat group.yml     
- name:
  hosts: node1
  vars:
  - passwordtom: tom123
  tasks:
  - name:  create group
    group:
      name: "{{ item }}"
    loop:
      - group1
      - group2
  - name: Add the
    user:
      name: tom
      comment: student
      uid: 2000
      groups: group1,group2
      shell: /bin/bash
      password: "{{ passwordtom | password_hash('sha512') }}"
      #mypassword该密码位置如果时字符串用单引号引起来，如果是变量则不需要单引号
[greg@control ansible]$ ansible-playbook user.yml -v
验证方式：
[greg@bastion ansible]$ ansible dev -m shell -a 'tail /etc/shadow'

Ansible网页搜索：password_hash--Using filter--网页中查找password_hash，查看密码哈希方式，一定注意是512
Ansible官网：  https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html
      模块中：append: yes    如果想额外添加附加群组，此选项需要yes(usermod -a -G  grouptest u1) 
```

### 管理存储

分区、lvm，格式化、挂载、交换分区

##### parted、lvg、lvol、filesystem、mount	



block---pv----vg（pe）---lv

##### parted模块

```yaml
[greg@bastion ansible]$ cat parted.yml 
---
- name:
  hosts:  node3 
  tasks:
  - name: Create a new primary partition
    parted:
      device: /dev/vdb
      number: 1
      state: present
      part_end: 1GiB

  - name: Create a new primary partition
    parted:
      device: /dev/vdb
      number: 2
      state: present
      part_start: 1GiB
      part_end: 2GiB

parted 如果一个分区分1G，开始 结束怎么设置？从哪个位置开始都可以吗？只要结束减去开始等于1G就就行是吗

分区时，第一个分区要从哪分？1M 2048s扇区
part_start  1MiB 
part_end  1GiB
```

##### lvg

```yaml
  tasks:
  - name: Create a volume group
    lvg:
      vg: vg100
      #pvs: /dev/vdb1,/dev/vdb2 
      pvs:
      - /dev/vdb1
      - /dev/vdb2
      pesize: 32

```

##### lvol

```yaml
  - name: Create a logical volume of 512m
    lvol:
      vg: vg100
      lv: lv100
      size: 512
      
      默认单位MB
```

##### filesystem

```bash

  - name: Create a xfs
    filesystem:
      fstype: xfs
      dev: /dev/vg100/lv100
      #dev: /dev/mapper/vg100-v100
      
    等同于：mkfs.xfs /dev/vg100/lv100

ansible 172.25.250.12 -m shell -a 'lsblk --fs /dev/vg100/lv100
```

##### mount

```yaml
  - name: Touch a directory    创建一个挂载点
    file:
      path: /mnt/dir1
      state: directory

  - name: 将lvm文件系统挂载到/mnt/dir1上
    mount:
      path: /mnt/dir1
      src: /dev/vg100/lv100
      fstype: xfs
      opts: defaults
      state: mounted
      
      总结：
      state：
      present    将配置信息写入/etc/fstab,不挂载
      mounted	 将配置信息写入/etc/fstab,并挂载，并且自动创建挂载点
      unmounted  不改变/etc/fstab信息,卸载
      absent     删除/etc/fstab信息，并卸载
      remounted  重新挂载
```

### 使用普通用户远程管理受管主机（重点）

```
【超级用户远程管理方式】
vim /home/greg/ansible/ansible.cfg
remote_user=root
host_key_checking = False

vim /home/greg/ansible/inventory
[all:vars]
ansible_password=redhat

【普通用户远程管理方式】
需求，请使用greg用户远程管理受管主机
【bastion】控制节点
ansible.cfg
[defaults]
remote_user = greg
host_key_checking = False

[privilege_escalation]
become=True
become_method=sudo 
become_user=root
become_ask_pass=false
----------------------------------------以下配置考试环境下已做
【bastion】管理节点
ssh-keygen 
三个回车
ssh-copy-id greg@workstation
ssh greg@workstation

其他受管主机上每一个主机都做如下操作
[root@workstation ~]# useradd  greg
[root@workstation ~]# echo redhat | passwd --stdin greg
[root@workstation ~]# visudo
greg    ALL=(ALL)       NOPASSWD: ALL
```

